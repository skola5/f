<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dino 3D – Slå sönder allt!</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto,Arial}
    #hud{
      position:fixed;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between
    }
    .topbar{display:flex;gap:12px;align-items:center;padding:12px}
    .chip{pointer-events:auto;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.15);
      border-radius:10px;padding:8px 12px;font-size:14px}
    .right{margin-left:auto;display:flex;gap:10px}
    #center{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center}
    #start,#gameover{
      display:none; pointer-events:auto; background:rgba(2,6,23,.82);
      border:1px solid rgba(255,255,255,.15); border-radius:16px; padding:20px 26px; min-width:280px
    }
    h1{margin:.3em 0 .1em;font-size:28px}
    p{margin:.2em 0 .6em;color:#cbd5e1;font-size:14px}
    button{
      cursor:pointer;background:#111827;color:#e5e7eb;border:1px solid rgba(255,255,255,.2);
      border-radius:12px;padding:10px 14px;font-size:14px
    }
    #healthbar {
      position:fixed;left:12px;bottom:12px;width:260px;height:14px;background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.18);border-radius:10px;overflow:hidden
    }
    #healthfill { height:100%;background:#22c55e;width:100% }
    canvas{display:block}
    @media (max-width:640px){
      .chip{font-size:12px}
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="topbar">
      <div class="chip">Poäng: <b id="score">0</b></div>
      <div class="chip">Fiender kvar: <b id="enemies">0</b></div>
      <div class="right">
        <div class="chip">WASD: gå · Space: hoppa · Klick: slå · Höger mus: rotera · R: omstart</div>
      </div>
    </div>
    <div id="center">
      <div id="start">
        <h1>Dino 3D</h1>
        <p>Spring runt, slå sönder fiender och överlev så länge du kan.</p>
        <p><b>Välj din hjälte:</b></p>
        <div style="display:flex;gap:14px;justify-content:center;margin:8px 0 14px">
          <button id="choose1">Martin Borg (dino.png)</button>
          <button id="choose2">Elisabeth Lindskoug (dino2.png)</button>
        </div>
        <button id="play">Starta spelet</button>
        <p style="font-size:12px;color:#94a3b8;margin-top:10px">Lägg <code>dino.png</code> och <code>dino2.png</code> i samma mapp som denna HTML.</p>
      </div>
      <div id="gameover">
        <h1>Game Over</h1>
        <p>Poäng: <b id="finalScore">0</b></p>
        <button id="restart">Spela igen (R)</button>
      </div>
    </div>
    <div id="healthbar"><div id="healthfill"></div></div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ------- DOM refs -------
    const scoreEl = document.getElementById('score');
    const enemiesEl = document.getElementById('enemies');
    const startBox = document.getElementById('start');
    const overBox = document.getElementById('gameover');
    const finalScoreEl = document.getElementById('finalScore');
    const playBtn = document.getElementById('play');
    const restartBtn = document.getElementById('restart');
    const choose1 = document.getElementById('choose1');
    const choose2 = document.getElementById('choose2');
    const healthFill = document.getElementById('healthfill');

    let chosenHero = 'dino.png'; // default
    choose1.onclick = () => chosenHero = 'dino.png';
    choose2.onclick = () => chosenHero = 'dino2.png';

    // ------- Renderer / Scene / Camera -------
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#0b1020');

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0, 6, 12);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 6;
    controls.maxDistance = 26;
    controls.maxPolarAngle = Math.PI * 0.49;

    // ------- Lights -------
    const hemi = new THREE.HemisphereLight(0xbddcff, 0x334466, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(8, 12, 6);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024,1024);
    scene.add(dir);

    // ------- Ground -------
    const groundGeo = new THREE.PlaneGeometry(200, 200, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x0f1b2f, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Subtle grid lines
    const grid = new THREE.GridHelper(200, 100, 0x2a3b5c, 0x1a2842);
    grid.position.y = 0.01;
    scene.add(grid);

    // ------- Player (capsule) -------
    const player = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.5, 1.2, 8, 16),
      new THREE.MeshStandardMaterial({ color: 0x22d3ee, roughness:.6, metalness:.1 })
    );
    body.castShadow = true;
    player.add(body);
    player.position.set(0, 1.1, 0);
    scene.add(player);

    // Billboard with chosen hero face (dino.png/dino2.png)
    const loader = new THREE.TextureLoader();
    const heroBoard = new THREE.Mesh(
      new THREE.PlaneGeometry(1.2, 1.2),
      new THREE.MeshBasicMaterial({ transparent:true })
    );
    heroBoard.position.set(0, 2.2, 0);
    player.add(heroBoard);

    function setHeroTexture(path){
      loader.load(path, tex => {
        tex.colorSpace = THREE.SRGBColorSpace;
        heroBoard.material.map = tex;
        heroBoard.material.needsUpdate = true;
      });
    }
    setHeroTexture(chosenHero);

    // ------- Props using dino images as world billboards -------
    const makeBillboard = (path, x, z, w=2, h=2) => {
      const mat = new THREE.MeshBasicMaterial({ transparent:true });
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
      mesh.position.set(x, h*0.5, z);
      mesh.userData.billboard = true;
      loader.load(path, tex => {
        tex.colorSpace = THREE.SRGBColorSpace;
        mat.map = tex; mat.needsUpdate = true;
      });
      scene.add(mesh);
      return mesh;
    };
    makeBillboard('dino.png', 6, -4, 3, 3);
    makeBillboard('dino2.png', -8, 5, 3, 3);

    // ------- Enemies (boxes) -------
    const enemies = [];
    function spawnEnemy(){
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(1,1,1),
        new THREE.MeshStandardMaterial({ color: 0xfb7185, roughness:.8 })
      );
      box.castShadow = true;
      const radius = 18 + Math.random()*10;
      const angle = Math.random()*Math.PI*2;
      box.position.set(Math.cos(angle)*radius, 0.5, Math.sin(angle)*radius);
      box.userData.hp = 2;
      scene.add(box);
      enemies.push(box);
      enemiesEl.textContent = enemies.length;
    }

    // ------- Attack effect -------
    const attackRing = new THREE.Mesh(
      new THREE.TorusGeometry(1.2, 0.06, 8, 24),
      new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0 })
    );
    attackRing.rotation.x = -Math.PI/2;
    attackRing.position.y = 0.2;
    player.add(attackRing);
    let attackCooldown = 0;

    // ------- Movement / physics -------
    const keys = {};
    window.addEventListener('keydown', e=>{
      keys[e.code] = true;
      if (e.code === 'Space') wantJump = true;
      if (e.code === 'KeyR' && gameState==='over') resetGame();
    });
    window.addEventListener('keyup', e=> keys[e.code] = false);

    let vel = new THREE.Vector3();
    let onGround = true;
    let wantJump = false;
    const speed = 6;
    const jumpVel = 8;
    const gravity = -20;

    function move(dt){
      // camera-relative WASD
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

      let moveDir = new THREE.Vector3();
      if (keys['KeyW']) moveDir.add(forward);
      if (keys['KeyS']) moveDir.addScaledVector(forward, -1);
      if (keys['KeyA']) moveDir.addScaledVector(right, -1);
      if (keys['KeyD']) moveDir.add(right);
      if (moveDir.lengthSq()>0) moveDir.normalize();

      // horizontal velocity
      vel.x = THREE.MathUtils.damp(vel.x, moveDir.x*speed, 10, dt);
      vel.z = THREE.MathUtils.damp(vel.z, moveDir.z*speed, 10, dt);

      // gravity & jump
      vel.y += gravity*dt;
      if (onGround){
        vel.y = Math.max(vel.y, 0);
        if (wantJump){ vel.y = jumpVel; onGround = false; }
      }
      wantJump = false;

      // integrate
      player.position.addScaledVector(vel, dt);

      // ground collision
      if (player.position.y <= 1.1){
        player.position.y = 1.1;
        onGround = true;
      }

      // face movement direction (if moving)
      const horiz = new THREE.Vector3(vel.x,0,vel.z);
      if (horiz.lengthSq()>0.001){
        const targetY = Math.atan2(horiz.x, horiz.z);
        player.rotation.y = THREE.MathUtils.damp(player.rotation.y, targetY, 10, dt);
      }

      // camera follow (soft)
      const camTarget = new THREE.Vector3().copy(player.position).add(new THREE.Vector3(0,3,8).applyAxisAngle(new THREE.Vector3(0,1,0), 0));
      camera.position.lerp(camTarget, 1 - Math.pow(0.001, dt*60));
      controls.target.lerp(new THREE.Vector3(player.position.x, player.position.y+1.2, player.position.z), 1 - Math.pow(0.001, dt*60));
    }

    // ------- Attack / combat -------
    function tryAttack(){
      if (attackCooldown > 0 || gameState!=='playing') return;
      attackCooldown = 0.35; // seconds
      // flash ring
      attackRing.material.opacity = 0.9;
      attackRing.scale.set(0.6,0.6,0.6);
      // hit test: sphere in front of player
      const dir = new THREE.Vector3(0,0,-1).applyEuler(player.rotation).normalize();
      const center = new THREE.Vector3().copy(player.position).addScaledVector(dir, 1.4); center.y = 0.5;
      const radius = 1.2;
      let hits = 0;
      for (let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        const d = e.position.distanceTo(center);
        if (d <= radius+0.8){
          e.userData.hp -= 1;
          e.material.color.setHex(0xfca5a5);
          e.scale.setScalar(0.9 + 0.2*e.userData.hp);
          if (e.userData.hp <= 0){
            // pop!
            scene.remove(e);
            enemies.splice(i,1);
            score += 10;
          } else {
            score += 2;
          }
        }
      }
      enemiesEl.textContent = enemies.length;
      scoreEl.textContent = score;
    }
    renderer.domElement.addEventListener('pointerdown', (e)=>{
      if (e.button === 0) tryAttack();
    });
    renderer.domElement.addEventListener('contextmenu', e=> e.preventDefault());

    // ------- Enemy AI -------
    function updateEnemies(dt){
      for (const e of enemies){
        const toPlayer = new THREE.Vector3().subVectors(player.position, e.position); toPlayer.y = 0;
        const dist = toPlayer.length();
        if (dist>0.001) toPlayer.normalize();
        const run = 2.4; // enemy speed
        e.position.addScaledVector(toPlayer, run*dt);
        e.lookAt(player.position.x, e.position.y, player.position.z);
        // damage player if touching
        if (dist < 1.0){
          hurt(10*dt); // DPS
        }
      }
    }

    // ------- Health / score / state -------
    let score = 0;
    let health = 100;
    function hurt(d){
      health = Math.max(0, health - d);
      healthFill.style.width = `${health}%`;
      if (health <= 0 && gameState==='playing'){
        gameOver();
      }
    }

    let gameState = 'menu'; // 'menu' | 'playing' | 'over'
    function startGame(){
      // reset world
      for (const e of enemies) scene.remove(e);
      enemies.length = 0;
      for (let i=0;i<6;i++) spawnEnemy();
      score = 0; scoreEl.textContent = score;
      health = 100; healthFill.style.width = '100%';
      player.position.set(0,1.1,0);
      vel.set(0,0,0);
      setHeroTexture(chosenHero);
      enemiesEl.textContent = enemies.length;

      startBox.style.display = 'none';
      overBox.style.display = 'none';
      gameState = 'playing';
      lastSpawn = 0;
    }
    function gameOver(){
      gameState = 'over';
      finalScoreEl.textContent = score;
      overBox.style.display = 'block';
    }
    function resetGame(){
      startBox.style.display = 'block';
      overBox.style.display = 'none';
      gameState = 'menu';
    }

    playBtn.onclick = startGame;
    restartBtn.onclick = resetGame;
    window.addEventListener('keydown', e=>{
      if (e.code==='KeyR' && gameState==='over') resetGame();
    });

    // ------- Spawning over time -------
    let last = 0;
    let lastSpawn = 0;
    function tick(t){
      const now = t*0.001;
      const dt = Math.min(0.033, now - last || 0.016);
      last = now;

      if (gameState==='playing'){
        move(dt);
        updateEnemies(dt);

        // spawn more gradually
        lastSpawn += dt;
        const want = 10 + Math.floor(score/50); // target count grows with score
        if (lastSpawn > 2 && enemies.length < want){
          spawnEnemy();
          lastSpawn = 0;
        }

        // attack ring animate
        if (attackCooldown > 0){
          attackCooldown -= dt;
          attackRing.material.opacity = Math.max(0, attackRing.material.opacity - dt*2.5);
          const s = attackRing.scale.x + dt*3.5; attackRing.scale.set(s,s,s);
        } else {
          attackRing.scale.set(1,1,1);
        }
      }

      // make billboards always face camera
      scene.traverse(obj=>{
        if (obj.userData.billboard){
          obj.lookAt(camera.position);
        }
      });

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // ------- Resize -------
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ------- Show menu at start -------
    startBox.style.display = 'block';
  </script>
</body>
</html>
